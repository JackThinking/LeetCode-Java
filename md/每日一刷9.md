---
title: 每日一刷9
date: 2018-06-11 10:52:21
tags:
    - java
    - leetcode
---
Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.
Note: For the purpose of this problem, we define empty string as valid palindrome.
**Example 1**:
```
Input: "A man, a plan, a canal: Panama"
Output: true
```
**Example 2**:
```
Input: "race a car"
Output: false
```
```java
class Solution {
    public boolean isPalindrome(String s) {
        String test = s.replaceAll("[^a-z^A-Z^0-9]", "").toLowerCase();
        char[] arr = test.toCharArray();
        for (int i = 0; i < arr.length/2; i++) {
            if(arr[i] != arr[arr.length-i-1]){
                return false;
            }
        }
        return true;
    }
}
```
思路不难，先对字符串进行处理留下大小写和数字，然后大小写统一一下，然后收尾比较即可，我这边用的是string的正则表达式处理的方法，然后用toLowerCase()函数统一变成小写。但是这样效率较低。下边展示一下效率较高的用法：
```java
public class Solution {
    public boolean isPalindrome(String s){
        if(s == null||s.length() == 0){ //null和0的判断是不是重复了？
            return false;
        }
        int i = 0;
        int j = s.length()-1;
        while(i<j){
            char lc = s.charAt(i);
            char rc = s.charAt(j);
            if ((lc<65||lc>90)&&(lc<97||lc>122)&&(lc<48||lc>57)){
                i++;
                continue;
            }
            if ((rc<65||rc>90)&&(rc<97||rc>122)&&(rc<48||rc>57)){
                j--;
                continue;
            }
            if (lc!=rc){
                if (lc>=65 && lc<=90){
                    return (lc -'A') == (rc -'a');
                }
                if (lc>=97 && lc<=122){
                    return (lc -'a') == (rc -'A');
                }
                return false;
            }
            i++;
            j--;
        }
        return true;
    }
}
```
总体思路相同，但是用了人工写判断函数的方法，使得效率提高，还有一点，charAt()函数指向的值会随着里面i和j的变化自动变化。