---
title: 每日一刷4
date: 2018-06-06 15:30:44
tags:
    - leetcode
    - java
---
Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
1. Each row must contain the digits 1-9 without repetition.
2. Each column must contain the digits 1-9 without repetition.
3. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.
```java
class Solution {
    public boolean isValidSudoku(char[][] board) {
        for(int i = 0; i < 9; i++){
            Set<Character> rows = new HashSet<>();
            Set<Character> cols = new HashSet<>();
            Set<Character> blocks = new HashSet<>();
            int row = 3*(i/3);
            int col = 3*(i%3);
            for(int j = 0; j < 9; j++){
                if(board[i][j]!='.'&& !rows.add(board[i][j])) return false;
                if(board[j][i]!='.'&& !cols.add(board[j][i])) return false;
                if(board[row+j/3][col+j%3]!='.'&& !blocks.add(board[row+j/3][col+j%3])) return false;
            }
        }
        return true;
    }
}
```
这道题目比之前的记道题目明显难了很多，看了一下python的做法，利用了Python的自建函数，过于简洁也过于高深了，java的解决方法也有许多，我挑了一种我觉得兼顾了可理解和效率的一种方式，基本思想是对于每一列，每一行，每一个3*3区块都维护一个HashSet的列表（hashset的好处是可以检验加进来的数据是不是重复了，如果重复了就会对add()函数return false，这个也是作为判断函数的一个关键点。
第二个难点在于对于每一个区块内的数据位置进行定位，一开始我想不出来，后来看到了答案的做法能，首先是对于i进行分别乘和模运算，然后这样可以找到每个3*3区块的左上角的位置，然后具体的位置再依靠j的相关运算来进行。
总之，这道题具有一定的难度，借此学习到了hashset的一些简单用法，还有就是对于二维数组的定位。