---
title: 每日一刷10
date: 2018-06-12 14:23:42
tags:
    - java
    - leetcode
---
You are climbing a stair case. It takes n steps to reach to the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
Note: Given n will be a positive integer.
**Example 1:**
```
Input: 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
```
**Example 2:**
```
Input: 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
```
```java
class Solution {
    public int climbStairs(int n) {
        ArrayList<Integer> arrayList= new ArrayList<Integer>();
        arrayList.add(0, 1);
        arrayList.add(1, 1);
        for (int i = 2; i <= n; i++) {
            arrayList.add(i, arrayList.get(i-1)+arrayList.get(i-2));
        }
        return arrayList.get(n);
    }
}
```
这道题是最基础的动态规划题，动态规划题的关键点在于两个方面：第一点是找出状态转移方程，第二点是记录中间数据。所以动态规划是典型的牺牲存储换取时间的一种方式。该题可以理解为n步的方法可以考虑为n-1步的方法再走一步加上n-2的方法再走2步。凑巧就是斐波那契数列，自己做的方法用了arraylist用于动态扩展数组，其实没必要，因为已经知道了n个，只要用大小为n个的数组记录即可。下面再贴一个效率高一点的：
```java
class Solution {
    public int climbStairs(int n) {
        int[] sol = new int[n];
        if (n == 0) return 0;
        sol[0] = 1;
        if (n == 1) return 1;
        sol[1] = 2;
        if (n == 2) return 2;
        for (int i = 2; i < n; i++) {
            sol[i] = sol[i-1] + sol[i-2];
        }
        return sol[n-1];
    }
}
```