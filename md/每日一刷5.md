---
title: 每日一刷5
date: 2018-06-07 21:10:28
tags:
    - leetcode
    - java
---
You are given an n x n 2D matrix representing an image.
Rotate the image by 90 degrees (clockwise).
**Note**:
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.
Example:
```
Given input matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

rotate the input matrix in-place such that it becomes:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```
```java
class Solution {
    public void rotate(int[][] matrix) {
        int len = matrix.length;
        for(int i = 0; i < len; i++){
            for(int j = i+1; j < len; j++){
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }             
        }
        for(int i = 0; i < len; i++){
            reverse(matrix[i]);
        }
    }
    
    public static void reverse(int[] array){  
        for(int i=0;i<array.length/2;i++){  
            int temp = array[i];  
            array[i] = array[array.length-1-i];  
            array[array.length-1-i] = temp;  
        }  
    }
}
```
这道题难得是自己做出来的一道题，虽然方法并不是最好的，主要思想是将转换的过程分成两步，第一步是斜对角线元素替换，第二部是将每一行中的数组逆序，其中逆序操作还是参考了网上的方法（基本功还是不扎实），不过看了LeetCode上其他人的做法后发现，我的这个解决方法复杂度还是高了，主要是区别在i和j的右边界上。下面是复杂度较小的一个：
```java
public class Solution {
public void rotate(int[][] matrix) {
    int n=matrix.length;
    for (int i=0; i<n/2; i++) 
        for (int j=i; j<n-i-1; j++) {
            int tmp=matrix[i][j];
            matrix[i][j]=matrix[n-j-1][i];
            matrix[n-j-1][i]=matrix[n-i-1][n-j-1];
            matrix[n-i-1][n-j-1]=matrix[j][n-i-1];
            matrix[j][n-i-1]=tmp;
        }
    }
```
其他人虽然有不同做法，但是减低复杂度的本质就都在于“i<n/2”，于此同时j的循环次数也减低了，但是缺点在于其置换的逻辑变难了，需要画图理解一下。